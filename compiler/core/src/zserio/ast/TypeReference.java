package zserio.ast;

import java.util.ArrayList;
import java.util.List;

import zserio.antlr.ZserioParserTokenTypes;
import zserio.antlr.util.BaseTokenAST;
import zserio.antlr.util.ParserException;
import zserio.tools.StringJoinUtil;

/**
 * AST node for type references.
 *
 * A type reference is either a simple name or a sequence of simple names separated by dots referring to
 * a nested type, e.g. {@code Outer.Inner}.
 *
 * Type references are Zserio types as well.
 */
public class TypeReference extends TokenAST implements ZserioType, LinkAction
{
    /**
     * Default constructor.
     */
    public TypeReference()
    {
        referencedIds = new ArrayList<String>();
        ZserioTypeContainer.add(this);
    }

    @Override
    public Package getPackage()
    {
        return referencedType.getPackage();
    }

    @Override
    public String getName()
    {
        return name;
    }

    @Override
    public Iterable<ZserioType> getUsedTypeList()
    {
        throw new InternalError("TypeReference.getUsedTypeList() is not implemented!");
    }

    /**
     * Gets referenced type.
     *
     * @return Referenced type.
     */
    public ZserioType getReferencedType()
    {
        return referencedType;
    }

    @Override
    public void callVisitor(ZserioTypeVisitor visitor)
    {
        visitor.visitTypeReference(this);
    }

    /**
     * Sets flag to signal a need of checking if referenced type is non parametrized.
     *
     * This method is called by code generated by ANTLR using ZserioParser.g.
     */
    public void setNonParametrizedTypeCheck()
    {
        checkNonParametrizedType = true;
    }

    /**
     * Links this reference to the corresponding referenced type.
     *
     * @param scope Lexical scope to use for referenced type resolving.
     *
     * @throws ParserException Throws if the referenced type is unresolvable.
     */
    public void link(Scope scope) throws ParserException
    {
        // create reference name
        final StringJoinUtil.Joiner idJoiner = new StringJoinUtil.Joiner(Package.SEPARATOR);
        for (String referencedId : referencedIds)
            idJoiner.append(referencedId);
        name = idJoiner.toString();

        // resolve referenced type
        referencedType = scope.getPackage().getType(name);
        if (referencedType == null)
            throw new ParserException(this, "Unresolved referenced type '" + name + "'!");
        if (referencedType instanceof ConstType)
            throw new ParserException(this, "Invalid usage of constant '" +
                    referencedType.getName() + "' as a type!");
        if (referencedType instanceof SqlDatabaseType)
            throw new ParserException(this, "Invalid use of SQL database '" +
                    referencedType.getName() + "' as a type!");


        // call 'setUsedBy' method needed for documentation emitter
        final ZserioType owner = scope.getOwner();
        if (owner instanceof CompoundType)
        {
            final CompoundType ownerType = (CompoundType)owner;
            if (referencedType instanceof CompoundType)
                ((CompoundType)referencedType).setUsedByCompoundType(ownerType);
            else if (referencedType instanceof EnumType)
                ((EnumType)referencedType).setUsedByCompoundType(ownerType);
        }
        else if (owner instanceof ServiceType)
        {
            if (referencedType instanceof CompoundType)
                ((CompoundType)referencedType).setUsedByServiceType((ServiceType)owner);
            else if (referencedType instanceof Subtype)
                ((Subtype)referencedType).setUsedByServiceType((ServiceType)owner);
        }
    }

    @Override
    protected boolean evaluateChild(BaseTokenAST child) throws ParserException
    {
        switch (child.getType())
        {
        case ZserioParserTokenTypes.ID:
            referencedIds.add(child.getText());
            break;

        default:
            return false;
        }

        return true;
    }

    @Override
    protected void check() throws ParserException
    {
        final ZserioType referencedBaseType = resolveBaseType(referencedType);
        if (checkNonParametrizedType && referencedBaseType instanceof CompoundType)
        {
            final CompoundType referencedCompoundType = (CompoundType)referencedBaseType;
            if (referencedCompoundType.getParameters().size() > 0)
                throw new ParserException(this, "Referenced type '" + name +
                        "' is defined as parameterized type!");
        }
    }

    /**
     * Resolves referencedType (processes all subtypes in the definition chain).
     * Called at the end of linking phase.
     *
     * @return Resolved referenced type.
     *
     * @throws ParserException When cyclic definition is detected.
     */
    protected ZserioType resolve() throws ParserException
    {
        if (referencedType instanceof Subtype)
            return ((Subtype)referencedType).resolve();
        return referencedType;
    }

    /**
     * Resolves base type from type reference or subtype.
     *
     * Note that this method does not resolve ArrayType and TypeInstantiation.
     *
     * @param type Generic Zserio type to resolve.
     *
     * @return The input parameter 'type' if 'type' is not type reference or subtype, otherwise base type of
     *         the type reference or subtype specified by input parameter 'type'.
     */
    static public ZserioType resolveBaseType(ZserioType type)
    {
        ZserioType baseType = type;

        if (baseType instanceof TypeReference)
            baseType = ((TypeReference)baseType).referencedType;

        if (baseType instanceof Subtype)
            baseType = ((Subtype)baseType).getTargetBaseType();

        return baseType;
    }

    /**
     * Resolves referenced type from type reference.
     *
     * @param type Generic Zserio type to resolve.
     *
     * @return The input parameter 'type' if 'type' is not type reference, otherwise referenced type of
     *         the type reference specified by input parameter 'type'.
     */
    static public ZserioType resolveType(ZserioType type)
    {
        ZserioType resolvedType = type;
        if (resolvedType instanceof TypeReference)
            resolvedType = ((TypeReference)resolvedType).referencedType;

        return resolvedType;
    }

    private static final long serialVersionUID = 8158308333230987942L;

    private ZserioType              referencedType;
    private String                  name;
    private boolean                 checkNonParametrizedType;
    private List<String>            referencedIds;
}
